<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Eric Hayden Campbell - Verification is a misnomer </title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">EHC</a>
            </div>
            <div id="navigation">
                <!-- <a href="/">Home</a> -->
                <a href="../news.html">News</a>
                <!-- <a href="/papers.html">Publications</a>x -->
                <a href="../posts.html">Blog</a>
                <a href="../pdfs/cv.pdf">Vita</a>
                <a href="https://github.com/ericthewry">
	                <img src="../images/github.png" width="15" height="15" />
	                </a>
                <a href="https://www.linkedin.com/in/eric-campbell-ba339490/">
	                <img src="../images/linkedin.png" width="15" height="15" />
                </a>

            </div>
        </div>

        <div id="content">
	  <div class="info">
  <h1> Verification is a misnomer </h1>
  
    Posted on June  6, 2022
    
        by Eric Hayden Campbell
    
</div>

<p>When I try to describe what I do to non PL folks I often get a lot of geniune confusion and skepticism. When I say I try to verify the correctness of programs I’ve been asked everything from to “how do you model programs” to “what is correctness” and “what does it mean to verify a program”, and sometimes all three.</p>
<p>Each of these have standard answers. We model <em>programs</em> by doing our best to write down a formal description of a language that (1) follows the language specification, or when that fails (2) agrees with the dominant implementation of the language, or when <em>that</em> fails (3) agrees with our own sense of taste; <em>Correctness</em> is defined in terms of “specification”, which is defined in terms of a different program in a (usually different, usually declarative) language or logic, which we call a “specification”, and <em>verification</em> means that a computer checked that the program adheres to the specification.</p>
<p>Now, as practitioners of PL/FM/Verification, we understand that this process comes with a whole boatload of caveats, which aren’t necessarily clear. We understand that our langauge models may differ in non-trivial ways from the implemenations that are truly used in the wild (the so-called “reality gap”). We understand that specifications are hard to come by and may themselves be buggy (the so-called “specification problem”), and we understand that even when a computer verifies/certifies a programs correctness, that a whole lot of unverified code produced that proof itself (the so-called trusted compute base, or TCB).</p>
<p>But our fancy terms don’t obscure the fact that our models and our proofs and our artifacts often make massive assumptions about the correctness of other bits of code. Take as an example any Z3-driven dependent type system like F# or Liquid Haskell.</p>
<!-- something about  Eugene Wigner made the question famous in his 1960 essay, “The Unreasonable Effectiveness of Mathematics in the Natural Sciences.” -->

        </div>

        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
